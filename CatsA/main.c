#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>

#define MAXSIZE 200002

//на входе циклическая строка
//перестановка задается позицией своего начального элмента в исходной строке
//мы не храним массив всех перестановок, мы храним индексы перестановок
//задача - определить позицию строки после всей сортировки
//сортируем не сами строки а индексы строк

int main() {
    char *S = (char*)  malloc(MAXSIZE * sizeof(char)); // массив строки (строка)
    long *T = (long*)  malloc(MAXSIZE * sizeof(long)); // перестановки //нужен на этапе поразрядной сортировки
    long *P = (long*)  malloc(MAXSIZE * sizeof(long)); // массив в который каждой iтой перестановке ставится соответсвующий карман в который она попадает
    long *B = (long*)  malloc(MAXSIZE * sizeof(long)); // новый(следующий) карман
    long *M = (long*)  malloc(MAXSIZE * sizeof(long)); // для символов //из номеров исходных перестановок отсорт //индексы строк
    FILE * input = fopen( "input.txt", "r");
    fscanf(input, "%s", S);
    fclose(input);

    int n;
    n = strlen(S);

    //для корректной работы с индексами
    long st;
    st = (n > 256) ? (n) : (256);

    int *D = (int*)  malloc(st * sizeof(int)); //мощность алфавита

    for (long i = 0; i < n; ++i)  //init массив индексов
        M[i] = i;  //M:{0 1 2 3 4 5 ...}


    for (long i = 0; i < n; ++i) //номера карманов - коды символов в аски //init
        P[i] = S[i];

    long  u = 0, d = 0, k = 0; // k - это длинна символа который идентифицирует отдельно взятый карман
    long i1 = 0, c = 0, j = 0;

    /* сначала сортируем все перестановки по первым символам
     * смотрим кол-во уникальных карманов которые при этом образовались
     * выполняем их перенумерацию(каждой перестановке ставим номер кармана в который она попала)
     * зная что перестановки циклические, каждая(текущая) перестановка является суффиксом предшествующей
     * на первом этапе мы смещаемся к предыдущей перестановки вычитая единицу из индекса текущей
     * дальше вместо перестановок рассмативаем номера карманов которым пренадлежат перестановки
     * сортируем предшествующие перестановки по номерам карманов в которые попадают их префиксы(потому что они уже отсортированы)
     * дальше определяем новый набор карманов
     */
    //изначально к = 0, а n - длинна слова
    while (k < n){
        for (long i = 0; i < st; ++i) //изначально размеры карманов неизвестны
            D[i] = 0;

        for (long i = 0; i < n; ++i)    //подсчет размеров карманов
            D[P[i]]++;                  //номер кармана = аски коду символа

        u = 0; //кол-во предшествующиих карманов

        //из размеров карманов вычисляем их место положение
        for (long i = 0; i < st; ++i){      // вычисляем местоположение кармана
            d = u + D[i];                   // исходя от его размера
            D[i] = u;
            u = d;
        }

        //сортируруем сортируем предшественников по первым сиволам нынешних
        for (long i = 0; i < n; ++i){
            i1 = (M[i] - k + n) % n;    // вычисляем индекс предшественника перестановки
            c = P[i1];                  // карман в который попадает i1 перестоновка(определяет позицию в Д)
            j = D[c];                   // указывает позицию вспомогательного массива куда мы должны добавить перестановку(на начало кармана)
            T[j] = i1;                  // сортируем по предшественникам(старым разрядам)
            D[c] = j + 1;   //
        }
        //возвращаем содержимое в М (выполнили сортировку строк)
        for (long i = 0; i < n; ++i){
            M[i] = T[i];
       //     printf("%d ", M[i]);
        }
        //printf("\n");

        //далее обновляем список карманов
        B[M[0]] = 0; //самая первая перестановка автоматически идет в нулевой карман
        for (long i = 1; i < n; ++i){//нулевой рассмотрен
            //сравниваем пары сиволов текущей и предыдущей перестановки
            //сравнивем перестановку которая находится в массиве М на i месте с перестанокой на i - 1
            if ((P[ M[i] ] != P[ M[i-1]] ) || (P[ (M[i] + k)%n ] != P[ (M[i-1] + k)%n ])){
                B[ M[i] ] = B[ M[i - 1] ] + 1; //пары символов не совпали, переходим в новый корман
            } else {
                B[ M[i] ] = B[ M[i - 1] ];//карман все тот же
            }
        }
        //все записи из перекинули в первый массив карманов
        for(long i = 0; i < n; ++i)
            P[i] = B[i];

        for (long i = 0; i < n; ++i){
            printf("%c ", S[P[i]]);
        }
        printf("\n");

        k = (k != 0)?(k*2):(1);
    }

    //printf("------- FINISH -------\n");
    printf("P[0] = %d\n",P[0]);

    FILE *output;
    output = fopen( "output.txt", "w"); //открыли файл
    fprintf(output, "%d",P[0]);
    fclose(output);

    free(S);
    free(M);
    free(P);
    free(B);
    free(T);
    free(D);
    return 0;
}